import{_ as d,c as o,e,o as a}from"./app-Ofpg8krj.js";const c={};function r(l,t){return a(),o("div",null,[...t[0]||(t[0]=[e(`<h2 id="location-对象" tabindex="-1"><a class="header-anchor" href="#location-对象"><span>location 对象</span></a></h2><blockquote><p><code>location</code> 对象是 <code>windows</code>子对象，其中包含当前窗口中加载的文档有关的信息。 <code>location</code>对象的用处不只表现在它保存着当前文档的信息，还表现在它将<code>url</code>解析为独立的片段，可以通过不同的属性访问这些片段:</p></blockquote><h3 id="location-对象属性" tabindex="-1"><a class="header-anchor" href="#location-对象属性"><span>location 对象属性</span></a></h3><blockquote><p>一个完整的url 包括9个部分 协议://用户名：密码@域名：端口/路径；参数？查询#片段 不过几乎没有哪个url包含这些所有组件，最重要的三部分是协议，域名和路径:</p></blockquote><p>以该url为例：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">http://www.baidu.com:80/javaScript/?file=001/BOM/README.md/#location对象</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>属性</th><th>描述</th><th>可读写性</th><th>结果</th></tr></thead><tbody><tr><td>href</td><td>包含整个URL的一个字符串</td><td>读写</td><td><code>http://www.baidu.com:80/javaScript/001/BOM/?file=README.md#location对象</code></td></tr><tr><td>origin</td><td>包含页面来源的域名的标准形式字符串</td><td>只读</td><td><code>http://www.baidu.com:80</code></td></tr><tr><td>protocol</td><td>包含URL对应协议的字符串，最后有一个&quot;:&quot;</td><td>只读</td><td><code>http:</code></td></tr><tr><td>host</td><td>包含了域名和端口号的字符串，如没有端口号则只有域名</td><td>只读</td><td><code>www.baidu.com:80</code></td></tr><tr><td>hostname</td><td>包含URL域名的字符串</td><td>只读</td><td><code>www.baidu.com</code></td></tr><tr><td>port</td><td>包含端口号的字符串</td><td>只读</td><td><code>80</code></td></tr><tr><td>pathname</td><td>包含URL中路径部分的字符串，开头有一个&quot;/&quot;</td><td>只读</td><td><code>/javaScript/001/BOM/</code></td></tr><tr><td>search</td><td>包含URL参数（查询字符串）的字符串，开头有一个“?”</td><td>只读</td><td><code>?file=README.md</code></td></tr><tr><td>hash</td><td>包含块标识符的字符串，开头有一个&quot;#&quot;</td><td>只读</td><td><code>#location对象</code></td></tr></tbody></table><h3 id="location-对象方法" tabindex="-1"><a class="header-anchor" href="#location-对象方法"><span>location 对象方法</span></a></h3><table><thead><tr><th>属性</th><th>参数</th><th>返回值</th><th>功能</th><th>兼容性</th></tr></thead><tbody><tr><td>assign</td><td>url</td><td>undefined</td><td>加载给定URL的内容资源</td><td>全部</td></tr><tr><td>reload</td><td>Boolean</td><td>undefined</td><td>重新加载来自当前 URL的资源(刷新本页)</td><td>全部</td></tr><tr><td>replace</td><td>url</td><td>undefined</td><td>用给定的URL替换掉当前的资源</td><td>全部</td></tr><tr><td>toString</td><td>无</td><td>包含整个URL的字符串</td><td>获取本窗口的url(只能获取，无法修改，读取效果与<code>location.href</code>相同)</td><td>全部</td></tr></tbody></table><blockquote><p><code>location.assign</code> 与 <code>location.replace</code>的区别: <code>replace()</code>替换的新页面不会被保存在会话的历史 History中，这意味着用户将不能用后退按钮转到该页面</p></blockquote><p><code>location.reload</code> 的参数：</p><ul><li>false或未写参数：检测服务器上的文档是否已改变。如果文档已改变，reload() 会再次下载该文档。如果文档未改变，则该方法将从缓存中装载文档。这与用户单击浏览器的刷新按钮的效果是完全一样的。</li><li>true：那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档。这与用户在单击浏览器的刷新按钮时按住 Shift 健的效果是完全一样。</li></ul>`,12)])])}const n=d(c,[["render",r]]),s=JSON.parse('{"path":"/mds/javaScript/BOM/location.html","title":"","lang":"en-US","frontmatter":{},"git":{},"filePathRelative":"mds/javaScript/BOM/location.md"}');export{n as comp,s as data};
