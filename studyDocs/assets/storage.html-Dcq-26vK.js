import{_ as n,c as a,e,o as p}from"./app-BQyt5-5v.js";const l={};function t(o,s){return p(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理"><span>内存管理</span></a></h1><h2 id="内存生命周期" tabindex="-1"><a class="header-anchor" href="#内存生命周期"><span>内存生命周期</span></a></h2><p>不管什么程序语言，内存生命周期基本是一致的：</p><ol><li>分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放、归还</li></ol><p>所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像JavaScript这些高级语言中，大部分都是隐含的。</p><p>js的内存生命周期：</p><ol><li>定义变量时就完成了内存分配</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// 给数值变量分配内存</span></span>
<span class="line"><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;azerty&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 给字符串分配内存</span></span>
<span class="line"><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token keyword">null</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 给对象及其包含的值分配内存</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> a <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span> <span class="token comment">// 给函数（可调用的对象）分配内存</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</li><li>而内存的释放而依赖GC机制（高级语言解释器嵌入的“垃圾回收器”）。</li></ol><h2 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收"><span>垃圾回收</span></a></h2><h3 id="引用" tabindex="-1"><a class="header-anchor" href="#引用"><span>引用</span></a></h3><p>垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。</p><h4 id="引用计数垃圾收集-计数算法" tabindex="-1"><a class="header-anchor" href="#引用计数垃圾收集-计数算法"><span>引用计数垃圾收集(计数算法)</span></a></h4><p>把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。<br> 无法处理循环引用</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token comment">// 创建一个对象person，他有两个指向属性age和name的引用</span></span>
<span class="line"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">12</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;aaaa&#39;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 虽然设置为null，但因为person对象还有指向name的引用，因此name不会回收</span></span>
<span class="line"><span class="token keyword">var</span> p <span class="token operator">=</span> person<span class="token punctuation">;</span></span>
<span class="line">person <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment">//原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收</span></span>
<span class="line">p <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>           <span class="token comment">//原person对象已经没有引用，很快会被回收</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="循环引用-上面垃圾回收的限制" tabindex="-1"><a class="header-anchor" href="#循环引用-上面垃圾回收的限制"><span>循环引用(上面垃圾回收的限制)</span></a></h5><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">  obj<span class="token punctuation">.</span>a <span class="token operator">=</span> obj2<span class="token punctuation">;</span> <span class="token comment">// obj 引用 obj2</span></span>
<span class="line">  obj2<span class="token punctuation">.</span>a <span class="token operator">=</span> obj<span class="token punctuation">;</span> <span class="token comment">// obj2 引用 obj</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token string">&quot;azerty&quot;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</p><h4 id="标记-清除算法" tabindex="-1"><a class="header-anchor" href="#标记-清除算法"><span>标记-清除算法</span></a></h4><p>现代的浏览器已经不再使用引用计数算法了。现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。</p><p>标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。</p><h3 id="内存泄漏" tabindex="-1"><a class="header-anchor" href="#内存泄漏"><span>内存泄漏</span></a></h3><p>对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏。</p><h4 id="内存泄漏的识别方法" tabindex="-1"><a class="header-anchor" href="#内存泄漏的识别方法"><span>内存泄漏的识别方法</span></a></h4><p>如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。</p><ol><li>浏览器方法 <ol><li>打开开发者工具，</li><li>在顶部的Capture字段里面勾选 Memory 选择 Timeline 面板</li><li>点击左上角的录制按钮。</li><li>在页面上进行各种操作，模拟用户的使用情况。</li><li>一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。</li></ol></li></ol><p>如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。 反之，就是内存泄漏了。</p><ol start="2"><li>命令行方法 命令行可以使用 Node 提供的 <code>process.memoryUsage</code> 方法。</li></ol><p>process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节，</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//  rss:        所有内存占用，包括指令区和堆栈。</span></span>
<span class="line"><span class="token comment">//  heapTotal:     &quot;堆&quot;占用的内存，包括用到的和没用到的。</span></span>
<span class="line"><span class="token comment">//  heapUsed:    用到的堆的部分。</span></span>
<span class="line"><span class="token comment">//  external:     V8 引擎内部的 C++ 对象占用的内存。</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 判断内存泄漏，以heapUsed字段为准。</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="常见内存泄漏" tabindex="-1"><a class="header-anchor" href="#常见内存泄漏"><span>常见内存泄漏</span></a></h3><p>如果还需要兼容老旧浏览器，那么就需要注意代码中的循环引用问题。或者直接采用保证兼容性的库来帮助优化代码。</p><p>对现代浏览器来说，唯一要注意的就是明确切断需要回收的对象与根部的联系。有时候这种联系并不明显，且因为标记清除算法的强壮性，这个问题较少出现。最常见的内存泄露一般都与DOM元素绑定有关。</p><ol><li>绝对不要定义全局变量<br> JavaScript用一个有趣的方式管理未被声明的变量：对未声明的变量的引用在全局对象里创建一个新的变量。在浏览器的情况下，这个全局对象是 window 。为了防止这种意外，可以使用严格模式来阻止</li><li>手工解除变量引用<br> 一个变量已经确切是不再需要了，那么就可以手工解除变量引用，以使其被回收。</li><li>闭包</li><li>DOM外引用</li></ol>`,34)])])}const c=n(l,[["render",t]]),r=JSON.parse('{"path":"/mds/javaScript/high/storage.html","title":"内存管理","lang":"en-US","frontmatter":{},"git":{},"filePathRelative":"mds/javaScript/high/storage.md"}');export{c as comp,r as data};
